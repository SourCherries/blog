<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Carl Gaspar">
<meta name="dcterms.date" content="2023-08-09">

<title>Carl Gaspar - Why masked arrays are useful for data science. Part 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Carl Gaspar - Why masked arrays are useful for data science. Part 1">
<meta property="og:description" content="Ever needed to compare lots of variables and missing data made things super slow?">
<meta property="og:image" content="https://sourcherries.github.io/blog/posts/masked-arrays/featured.png">
<meta property="og:site-name" content="Carl Gaspar">
<meta property="og:image:height" content="640">
<meta property="og:image:width" content="1280">
<meta property="og:image:alt" content="Performance advantage for masked-matrix multiplication over loops">
<meta name="twitter:title" content="Carl Gaspar - Why masked arrays are useful for data science. Part 1">
<meta name="twitter:description" content="Ever needed to compare lots of variables and missing data made things super slow?">
<meta name="twitter:image" content="https://sourcherries.github.io/blog/posts/masked-arrays/featured.png">
<meta name="twitter:creator" content="@carl_m_gaspar">
<meta name="twitter:image-height" content="640">
<meta name="twitter:image-width" content="1280">
<meta name="twitter:image:alt" content="Performance advantage for masked-matrix multiplication over loops">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Carl Gaspar</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SourCherries"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/carl_m_gaspar"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Why masked arrays are useful for data science. Part 1</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">analysis</div>
                <div class="quarto-category">missing data</div>
                <div class="quarto-category">numpy</div>
                <div class="quarto-category">vectorization</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Carl Gaspar </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 9, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Ever needed to compare lots of variables and missing data made things super slow?</p>
<p>A surprisingly wide range of measures that are core to data science can be accelerated with the use of matrix multiplication. You just need to get creative when reformulating your computation.</p>
<p>But real-world data has missing values and these can make matrix multiplication useless. Does that mean one must resort to inefficient for-loops to keep track of missing values?</p>
<p>No.&nbsp;Using Numpy masked arrays one can still reap the benefits of matrix multiplication whilst making full use of one’s data.</p>
<p>Here I demonstrate the use of numpy masked arrays for the efficient calculation of <strong>percentage agreement</strong> among many binary variables.</p>
<p>In this post I cover:</p>
<ol type="1">
<li>What matrix multiplication (<strong>MM</strong>) is (<a href="#sec-matmul">Section&nbsp;1</a>)</li>
<li>Percentage agreement the slow way (<a href="#sec-agreement">Section&nbsp;2</a>)</li>
<li>Percentage agreement the fast way (<a href="#sec-vectorization">Section&nbsp;3</a>)</li>
<li>Why missing data are a problem for <strong>MM</strong> (<a href="#sec-curse">Section&nbsp;4</a>)</li>
<li>Show that Numpy masked arrays solves this problem (<a href="#sec-masked-arrays">Section&nbsp;5</a>)</li>
<li>Give some pointers on optimization (<a href="#sec-details">Section&nbsp;6</a>)</li>
<li>The takeaway. Go to <a href="#sec-takeaway">Section&nbsp;7</a> if you’re impatient!</li>
</ol>
<p>The <strong>covariance matrix</strong> is another measure we can efficiently compute using <strong>MM</strong> and masked arrays. I am leaving that for another post where I also describe existing solutions (<strong>coming soon</strong>).</p>
<p>The solution I describe here for efficient computation of <strong>percentage agreement</strong> is not something in any major Python package.</p>
<p>I also refer to a similar implementation of <strong>Cohen’s kappa</strong> I coded (in #sec-masked-arrays). <strong>Cohen’s kappa</strong> with efficient matrix-based handling of missing values is also missing in major Python packages.</p>
<p>But before we get to all that, let’s talk about <strong>matrix multiplication</strong> (<strong>MM</strong>).</p>
<section id="sec-matmul" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-matmul"><span class="header-section-number">1</span> Sums of products. Lots of them, fast</h2>
<p>As implemented in most popular packages like Python’s Numpy, <strong>MM</strong> let’s you rapidly calculate sums-of-products for many pairs of variables. So let’s start with sums-of-products.</p>
<p>Here is a single variable and it’s sum-of-products:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>sum_of_products <span class="op">=</span> (x<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sum_of_products)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>14</code></pre>
</div>
</div>
<p>Now we consider another variable <code>y</code> and calculate the sum-of-products between <code>x</code> and <code>y</code>:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>products <span class="op">=</span> np.multiply(x, y)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>sum_of_products <span class="op">=</span> products.<span class="bu">sum</span>()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(products)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sum_of_products)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[3 4 3]
10</code></pre>
</div>
</div>
<p>Now we package our <code>x</code> and <code>y</code> as the column vectors of a single matrix:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">3</span>],</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">2</span>, <span class="dv">2</span>],</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">3</span>, <span class="dv">1</span>]])</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>number_observations, number_variables <span class="op">=</span> X.shape</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>number_observations<span class="sc">}</span><span class="ss"> observations (rows)"</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>number_variables<span class="sc">}</span><span class="ss"> variables (columns)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3 observations (rows)
2 variables (columns)</code></pre>
</div>
</div>
<p>Why did with do this? If you matrix multiply <code>X</code> with itself you get something interesting:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.dot(X.transpose(), X)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(S)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[14 10]
 [10 14]]</code></pre>
</div>
</div>
<p><code>S[0,0]</code> is the sum-of-products of <code>x</code> with itself. <code>S[0,1]</code> is the sum-of-products of <code>x</code> with <code>y</code>. <code>S[1,0]</code> is also the sum-of-products of <code>x</code> with <code>y</code>. And <code>S[1,1]</code> is the sum-of-products of <code>y</code> with itself.</p>
<p>In other words, matrix multiplication (<strong>MM</strong>) gives you the sum-of-products for every pairwise comparison.</p>
<p>And as mentioned earlier, <strong>MM</strong> is computed very quickly using packages like Numpy.</p>
<p>But why do we care about sums-of-products for every pairwise comparison?</p>
<p>So many interesting measures/statistics can be reformulated as an efficient sequence of <strong>MM</strong>.</p>
<p>So with just a little bit of cleverness you can turn your very inefficient for-loops into a very efficient sequence of matrix operations.</p>
</section>
<section id="sec-agreement" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-agreement"><span class="header-section-number">2</span> Percentage agreement the slow way</h2>
<p>Imagine that 8 people filled out a survey consisting of 4 yes/no items:</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]]).transpose()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>col_labels <span class="op">=</span> [<span class="st">'Item '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">5</span>)]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>row_labels <span class="op">=</span> [<span class="st">'Person '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">9</span>)]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(X, columns<span class="op">=</span>col_labels, index<span class="op">=</span>row_labels))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          Item 1  Item 2  Item 3  Item 4
Person 1       0       0       0       1
Person 2       0       0       1       1
Person 3       0       0       0       1
Person 4       0       0       1       1
Person 5       1       1       0       0
Person 6       1       1       1       0
Person 7       1       1       0       0
Person 8       1       1       1       0</code></pre>
</div>
</div>
<p>You want to know if there are associations among these items.</p>
<p>A glance at this stylized data set suffices.</p>
<p>Item 1 is perfectly positively associated with item 2 in this sample; 100 percent of the responses are in agreement.</p>
<p>Item 1 is has no association with item 3 in this sample; guessing someone’s response to item 3 based their response to 1 is no better than a coin flip (50 percent).</p>
<p>Item 1 is perfectly negatively associated with item 4; 0 percent of the responses are in agreement.</p>
<p>If you have a much larger data set, you might decide to use for-loops like this:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pa_loop(X):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    number_samples, number_variables <span class="op">=</span> X.shape</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    percent_agreement <span class="op">=</span> np.zeros((number_variables, number_variables))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item_a <span class="kw">in</span> <span class="bu">range</span>(number_variables):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> item_b <span class="kw">in</span> <span class="bu">range</span>(item_a<span class="op">+</span><span class="dv">1</span>, number_variables):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            percent_agreement[item_a, item_b] <span class="op">=</span> (X[:, item_a]<span class="op">==</span>X[:, item_b]).<span class="bu">sum</span>()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    percent_agreement <span class="op">/=</span> number_samples</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(percent_agreement)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>But this can be slow for large data sets:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> time <span class="im">import</span> perf_counter</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>number_samples, number_variables <span class="op">=</span> <span class="dv">1000</span>, <span class="dv">1000</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.choice([<span class="fl">0.</span>, <span class="fl">1.</span>], size<span class="op">=</span>(number_samples, number_variables), replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>tic <span class="op">=</span> perf_counter()</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>percent_agreement <span class="op">=</span> pa_loop(X)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>toc <span class="op">=</span> perf_counter()</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Computing all pairwise percentage agreements took </span><span class="sc">{</span>toc<span class="op">-</span>tic<span class="sc">:0.4f}</span><span class="ss"> seconds."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Computing all pairwise percentage agreements took 1.8366 seconds.</code></pre>
</div>
</div>
<p>This may not seem so bad. But consider that</p>
<ol type="1">
<li>Things will be much worse when missing data are considered (<a href="#sec-curse">Section&nbsp;4</a>).</li>
<li>Data exploration might mean iterating this code many times.</li>
<li><strong>Percentage agreement</strong> is simpler than some other measures/statistics.</li>
</ol>
<p>How can we use matrix multiplication to speed things up? We’ll have to use some tricks but it’s not that hard.</p>
</section>
<section id="sec-vectorization" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-vectorization"><span class="header-section-number">3</span> Percentage agreement the fast way</h2>
<p>Here is a simple case with yes and no responses for 2 items coded as 1s and 0s respectively:</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">item 1</th>
<th style="text-align: center;">item 2</th>
<th style="text-align: center;">agreement</th>
<th style="text-align: center;">yes-yes</th>
<th style="text-align: center;">no-no</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>What we want is a column like <em>agreement</em> above whose sum (<code>2</code>) gives us the number of agreements. We then divide 2 by 4 to get 50-percent agreement.</p>
<p>Treating <strong>item 1</strong> as a row vector and <strong>item 2</strong> as a column vector, we can perform matrix multiplication to get the sum of <strong>yes-yes</strong> (<code>1</code>). As an intermediate step in matrix multiplication, our 2 vectors are multiplied value-by-value giving us the yes-yes column above. Summing is the final step of matrix multiplication (<code>1</code>).</p>
<p>Agreements can be either <strong>yes-yes</strong> or <strong>no-no</strong> so we still need to obtain that sum before we can measure number of agreements. That’s easy. We simply flip the values in <strong>item 1</strong> and <strong>item 2</strong> from 0 to 1, and 1 to 0:</p>
<p><span class="math display">\[
new = \lvert old-1 \rvert
\]</span></p>
<p>Matrix multiplication of these complementary vectors for <strong>item 1</strong> and <strong>item 2</strong> (not shown here) gives us our sum of <strong>no-no</strong>, whose intermediate step is the <strong>no-no</strong> column above.</p>
<p>The above example is for 2 items but the power of matrix multiplication is that we are multiplying <strong>matrices</strong> – as many items as we want. And the result is a matrix of all pairwise comparisons. In other words, we can obtain a matrix of percentage agreement for all pairwise comparisons using a simple sequence of matrix-based operations, like this:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pa_vect(X):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    number_samples, number_variables <span class="op">=</span> X.shape <span class="co"># (n x k)</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    yesYes <span class="op">=</span> np.dot(X.transpose(), X)          <span class="co"># counts of yes-yes (k x k)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">abs</span>(X<span class="op">-</span><span class="dv">1</span>, out<span class="op">=</span>X)                         <span class="co"># [0,1] -&gt; [1,0]</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    noNo <span class="op">=</span> np.dot(X.transpose(), X)            <span class="co"># counts of no-no   (k x k)</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> yesYes <span class="op">+</span> noNo                          <span class="co"># counts of agreements (k x k)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> S <span class="op">/</span> number_samples                     <span class="co"># percentage agreements (k x k)   </span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>How much faster is this compared to the loop-based computation?</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>number_samples <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>number_variables <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>seconds <span class="op">=</span> np.zeros((<span class="bu">len</span>(number_variables), <span class="dv">2</span>))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>iterations <span class="op">=</span> <span class="dv">36</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, nvl <span class="kw">in</span> <span class="bu">enumerate</span>(number_variables):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> np.random.choice([<span class="fl">0.</span>, <span class="fl">1.</span>], size<span class="op">=</span>(number_samples, nvl), replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        tic <span class="op">=</span> perf_counter()<span class="op">;</span> percent_agreement <span class="op">=</span> pa_loop(X)<span class="op">;</span> toc <span class="op">=</span> perf_counter()</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        seconds_loop <span class="op">=</span> toc<span class="op">-</span>tic</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        tic <span class="op">=</span> perf_counter()<span class="op">;</span> percent_agreement <span class="op">=</span> pa_vect(X)<span class="op">;</span> toc <span class="op">=</span> perf_counter()</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        seconds_vect <span class="op">=</span> toc<span class="op">-</span>tic</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        seconds[i, <span class="dv">0</span>] <span class="op">+=</span> seconds_loop</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        seconds[i, <span class="dv">1</span>] <span class="op">+=</span> seconds_vect</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>seconds <span class="op">/=</span> iterations</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(seconds, </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>                  columns<span class="op">=</span>[<span class="st">'loop'</span>,<span class="st">'matrix-based'</span>],</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>                  index<span class="op">=</span>number_variables)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">

<div>

<table class="dataframe table table-sm table-striped">
  <thead>
    <tr>
      <th></th>
      <th>loop</th>
      <th>matrix-based</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>10</th>
      <td>0.000162</td>
      <td>0.000173</td>
    </tr>
    <tr>
      <th>50</th>
      <td>0.005817</td>
      <td>0.000225</td>
    </tr>
    <tr>
      <th>100</th>
      <td>0.023475</td>
      <td>0.000607</td>
    </tr>
    <tr>
      <th>500</th>
      <td>0.490164</td>
      <td>0.006845</td>
    </tr>
    <tr>
      <th>1000</th>
      <td>2.386646</td>
      <td>0.023026</td>
    </tr>
  </tbody>
</table>
</div>
</div>
</div>
<p>Let’s examine the speed up graphically:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>df.plot(loglog<span class="op">=</span><span class="va">True</span>, xlabel<span class="op">=</span><span class="st">"Number of variables"</span>, ylabel<span class="op">=</span><span class="st">"Seconds"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-11-output-1.png" width="599" height="431"></p>
</div>
</div>
<p>Matrix-based computation is definitely faster!</p>
<p>How much faster exactly?</p>
<p>Dividing the time taken by loop-based computation by the time taken by matrix-based computation gives us a speed-up. The larger the number the stronger the advantage for matrix-based computation:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>speed_up <span class="op">=</span> seconds[:,<span class="dv">0</span>] <span class="op">/</span> seconds[:,<span class="dv">1</span>]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.semilogx(number_variables, speed_up)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Number of variables"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Speed advantage"</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Matrix-based operation beats loops by miles"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-12-output-1.png" width="593" height="451"></p>
</div>
</div>
</section>
<section id="sec-curse" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-curse"><span class="header-section-number">4</span> The curse of missing data</h2>
<p>Numpy is efficient because its data structures (matrices, vectors) have homogeneous elements. Everything in a numpy matrix for example is <code>int32</code> or whatever data type you set it to be (e.g., <code>float64</code>).</p>
<p>If you have an element that is undefined for some reason, like a missing value for example, then it is usually represented as <code>nan</code>. That stands for not-a-number and is common in programming languages. Note that <code>nan</code> is only defined for floating point data types.</p>
<p>For convenience, let’s assign a variable to represent <code>np.nan</code> so we do not have to type <code>np.nan</code> all the time:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s see why missing values in Numpy (<code>nan</code>) can be a problem for our <strong>MM</strong> solutions.</p>
<p>If we do any arithmetic that involves a <code>nan</code> we get a <code>nan</code> as a result:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"10 + nan is </span><span class="sc">{</span><span class="dv">10</span> <span class="op">+</span> M<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"23 * nan is </span><span class="sc">{</span><span class="dv">23</span> <span class="op">*</span> M<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>10 + nan is nan
23 * nan is nan</code></pre>
</div>
</div>
<p>So if we do matrix multiplication, we will get <code>nan</code> for every pair that has at least one <code>nan</code>:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]).reshape((<span class="dv">4</span>,<span class="dv">1</span>))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, M]).reshape((<span class="dv">4</span>,<span class="dv">1</span>))</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>mm <span class="op">=</span> np.dot(x.transpose(), y)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"matrix multiplication of </span><span class="sc">{</span>x<span class="sc">.</span>flatten()<span class="sc">}</span><span class="ss"> and </span><span class="sc">{</span>y<span class="sc">.</span>flatten()<span class="sc">}</span><span class="ss"> is </span><span class="sc">{</span>mm<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>matrix multiplication of [1 2 3 4] and [ 1.  2.  3. nan] is [[nan]].</code></pre>
</div>
</div>
<p>Now let’s see how we can deal with missing values in data sets.</p>
<p>There are simple cases which are uncommon, and there are complex cases which are common.</p>
<p>Here is an extremely simple case:</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>              [M, M, M, M]])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>col_labels <span class="op">=</span> [<span class="st">'Item '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">5</span>)]</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>row_labels <span class="op">=</span> [<span class="st">'Person '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">6</span>)]</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(X, columns<span class="op">=</span>col_labels, index<span class="op">=</span>row_labels))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>          Item 1  Item 2  Item 3  Item 4
Person 1     0.0     0.0     0.0     1.0
Person 2     0.0     0.0     1.0     1.0
Person 3     1.0     1.0     0.0     0.0
Person 4     1.0     1.0     1.0     0.0
Person 5     NaN     NaN     NaN     NaN</code></pre>
</div>
</div>
<p>Here we can perform <a href="https://en.wikipedia.org/wiki/Listwise_deletion">listwise deletion</a>, with no loss of information:</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>X[:<span class="op">-</span><span class="dv">1</span>,:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>array([[0., 0., 0., 1.],
       [0., 0., 1., 1.],
       [1., 1., 0., 0.],
       [1., 1., 1., 0.]])</code></pre>
</div>
</div>
<p>But the missing values in real data will often be in different records for different variables. Here is an extreme case:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, M, M],</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">0</span>, M, M],</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, M, M],</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, M, M],</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, <span class="dv">0</span>, M],</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, <span class="dv">1</span>, M],</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, <span class="dv">0</span>, M],</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, <span class="dv">1</span>, M],</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, M, <span class="dv">1</span>],</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, M, <span class="dv">1</span>],</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, M, <span class="dv">0</span>],</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, M, <span class="dv">0</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we do listwise deletion we end up with no data.</p>
<p>What we want is <strong>pairwise deletion</strong> instead of listwise deletion. We want to only exclude samples on a pairwise basis in order to retain the most information.</p>
<p>This is pretty straightforward with our loop-based code. We simply add list comprehensions inside the inner loop, which excludes samples whenever a value is missing for one of the pairs under consideration:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pa_loop_missing(X):</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    _, number_variables <span class="op">=</span> X.shape</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    percent_agreement <span class="op">=</span> np.zeros((number_variables, number_variables))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item_a <span class="kw">in</span> <span class="bu">range</span>(number_variables):</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> item_b <span class="kw">in</span> <span class="bu">range</span>(item_a<span class="op">+</span><span class="dv">1</span>, number_variables):</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> X[:, item_a]</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>                y <span class="op">=</span> X[:, item_b]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>                <span class="co"># remove observations where missing for either x or y</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>                products <span class="op">=</span> [a<span class="op">*</span>b <span class="cf">for</span> a, b <span class="kw">in</span> <span class="bu">zip</span>(x,y)]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>                nx <span class="op">=</span> [xi <span class="cf">for</span> xi, pi <span class="kw">in</span> <span class="bu">zip</span>(x, products) <span class="cf">if</span> <span class="kw">not</span> math.isnan(pi)]</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>                ny <span class="op">=</span> [yi <span class="cf">for</span> yi, pi <span class="kw">in</span> <span class="bu">zip</span>(y, products) <span class="cf">if</span> <span class="kw">not</span> math.isnan(pi)]</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>                sumA <span class="op">=</span> <span class="bu">sum</span>([va<span class="op">==</span>vb <span class="cf">for</span> va, vb <span class="kw">in</span> <span class="bu">zip</span>(nx, ny)])</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>                totA <span class="op">=</span> <span class="bu">len</span>(nx)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>                percent_agreement[item_a, item_b] <span class="op">=</span> [sumA <span class="op">/</span> totA <span class="cf">if</span> totA <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> math.nan][<span class="dv">0</span>]</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(percent_agreement)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>pa_loop_missing(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>array([[0. , 1. , 0.5, 0. ],
       [0. , 0. , nan, nan],
       [0. , 0. , 0. , nan],
       [0. , 0. , 0. , 0. ]])</code></pre>
</div>
</div>
<p>This works but as we will see in <a href="#sec-masked-arrays">Section&nbsp;5</a>, this solution is very slow. That is not a surprise since we now effectively have 3 nested loops.</p>
<p>And if we try out matrix-based solution we end up no result except for the agreement of the first item with itself:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>pa_vect(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>array([[ 1., nan, nan, nan],
       [nan, nan, nan, nan],
       [nan, nan, nan, nan],
       [nan, nan, nan, nan]])</code></pre>
</div>
</div>
<p>Of course. We already knew this.</p>
<p>In fact, it seems impossible to avoid for-loops if one wants to perform pairwise deletion.</p>
<p>Or is it?</p>
</section>
<section id="sec-masked-arrays" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-masked-arrays"><span class="header-section-number">5</span> Masked arrays to the rescue</h2>
<p>As it turns out, <a href="https://numpy.org/doc/stable/reference/maskedarray.html">numpy masked arrays</a> effectively performs pairwise deletion when a matrix multiplication is performed!</p>
<p>Despite being very valuable, this feature of masked arrays is not something that appears to be commonly appreciated in discussions of what makes masked arrays useful.</p>
<p>For example, see the top-rated responses to this <a href="https://stackoverflow.com/questions/55987642/why-are-numpy-masked-arrays-useful">Stack Overflow query</a> on <em>Why are Numpy masked arrays useful?</em> Practical examples like what’s presented here are hard to find.</p>
<p>So let’s make sure pairwise deletion is indeed performed using a matrix multiplication of masked arrays. I was not sure myself and had to check using numerous examples. Here is a really simple example I showed you before:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">0</span>, <span class="dv">0</span>, M, M],</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, <span class="dv">0</span>, M, M],</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, M, M],</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, <span class="dv">1</span>, M, M],</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, <span class="dv">0</span>, M],</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, <span class="dv">1</span>, M],</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, <span class="dv">0</span>, M],</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, <span class="dv">1</span>, M],</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, M, <span class="dv">1</span>],</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">0</span>, M, M, <span class="dv">1</span>],</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, M, <span class="dv">0</span>],</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">1</span>, M, M, <span class="dv">0</span>]])</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>col_labels <span class="op">=</span> [<span class="st">'Item '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,X.shape[<span class="dv">1</span>]<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>row_labels <span class="op">=</span> [<span class="st">'Person '</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,X.shape[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(X, columns<span class="op">=</span>col_labels, index<span class="op">=</span>row_labels))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>           Item 1  Item 2  Item 3  Item 4
Person 1      0.0     0.0     NaN     NaN
Person 2      0.0     0.0     NaN     NaN
Person 3      1.0     1.0     NaN     NaN
Person 4      1.0     1.0     NaN     NaN
Person 5      0.0     NaN     0.0     NaN
Person 6      0.0     NaN     1.0     NaN
Person 7      1.0     NaN     0.0     NaN
Person 8      1.0     NaN     1.0     NaN
Person 9      0.0     NaN     NaN     1.0
Person 10     0.0     NaN     NaN     1.0
Person 11     1.0     NaN     NaN     0.0
Person 12     1.0     NaN     NaN     0.0</code></pre>
</div>
</div>
<p>Clearly the sum of products between <strong>item</strong> 1 and itself should be <code>6</code>, between <strong>item</strong> 1 and 2 should be <code>2</code>, between <strong>item</strong> 1 and 3 should be <code>1</code>, and between <strong>item</strong> 1 and 4 should be <code>0</code>. You easily calculate the rest yourself.</p>
<p>Let’s see if matrix multiplication with masked arrays is consistent with pairwise deletion.</p>
<p>The first step is to import the masked array module, and convert <code>X</code> to a masked array such that <code>nan</code> values are identified as <em>masked</em>:</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.ma <span class="im">as</span> ma</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> ma.masked_invalid(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the rest is the easy. The masked array module contains almost all of the same functionality as numpy itself. So for example we can write <code>ma.dot()</code> instead of <code>np.dot()</code>:</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>yesYes <span class="op">=</span> ma.dot(R.transpose(), R)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(yesYes, columns<span class="op">=</span>col_labels, index<span class="op">=</span>col_labels))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        Item 1  Item 2  Item 3  Item 4
Item 1     6.0     2.0     1.0     0.0
Item 2     2.0     2.0     NaN     NaN
Item 3     1.0     NaN     2.0     NaN
Item 4     0.0     NaN     NaN     2.0</code></pre>
</div>
</div>
<p>Fantastic! Pairwise deletion without for loops!</p>
<p>But is this fast? Can we still get those juicy speed gains using matrix multiplication on masked arrays?</p>
<p>Let’s find out. First let’s re-code our function for matrix-computation of percentage agreement to perform all operations on a masked-array version of the data:</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pa_vect_missing(X):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> ma.masked_invalid(X)                <span class="co"># (n x k)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    yesYes <span class="op">=</span> ma.dot(R.transpose(), R)       <span class="co"># counts of yes-yes (k x k)</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> ma.<span class="bu">abs</span>(R<span class="op">-</span><span class="dv">1</span>)                         <span class="co"># [0,1] -&gt; [1,0]</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    noNo <span class="op">=</span> ma.dot(F.transpose(), F)         <span class="co"># counts of no-no   (k x k)</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> yesYes <span class="op">+</span> noNo                       <span class="co"># counts of agreements (k x k)</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    valid <span class="op">=</span> np.ones_like(R)                 <span class="co"># valid responses (n x k)</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    valid[ma.getmaskarray(R)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> np.dot(valid.transpose(), valid)    <span class="co"># valid count (k x k)</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> ma.multiply(S, N<span class="op">**-</span><span class="dv">1</span>)               <span class="co"># percentage agreement (k x k)</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And now let’s compare our new loop- and matrix-based functions across a range of data sizes. Here I simulate binary responses with 20-percent missing data on average, randomly dispersed across sample and variable:</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(seed<span class="op">=</span><span class="dv">12345</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>responses, probs <span class="op">=</span> [<span class="fl">0.</span>, <span class="fl">1.</span>, M], [<span class="fl">.4</span>, <span class="fl">.4</span>, <span class="fl">.2</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>number_samples_large <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>number_variables_large <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>]</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>seconds_missing <span class="op">=</span> np.zeros((<span class="bu">len</span>(number_variables_large), <span class="dv">2</span>))</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>iterations <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, nvl <span class="kw">in</span> <span class="bu">enumerate</span>(number_variables_large):</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(iterations):</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> rng.choice(responses, </span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>                   size<span class="op">=</span>(number_samples_large, nvl), </span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>                   replace<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>                   p<span class="op">=</span>probs)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    tic <span class="op">=</span> perf_counter()</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    percent_agreement <span class="op">=</span> pa_loop_missing(X)</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    toc <span class="op">=</span> perf_counter()</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    seconds_loop <span class="op">=</span> toc<span class="op">-</span>tic</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    tic <span class="op">=</span> perf_counter()</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    percent_agreement <span class="op">=</span> pa_vect_missing(X)</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    toc <span class="op">=</span> perf_counter()</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    seconds_vect <span class="op">=</span> toc<span class="op">-</span>tic</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>    seconds_missing[i, <span class="dv">0</span>] <span class="op">+=</span> seconds_loop</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    seconds_missing[i, <span class="dv">1</span>] <span class="op">+=</span> seconds_vect</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>seconds_missing <span class="op">/=</span> iterations</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>df_missing <span class="op">=</span> pd.DataFrame(seconds_missing, </span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>                          columns<span class="op">=</span>[<span class="st">'loop'</span>,<span class="st">'vectorized'</span>],</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>                          index<span class="op">=</span>number_variables_large)</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>df_missing.plot(loglog<span class="op">=</span><span class="va">True</span>, xlabel<span class="op">=</span><span class="st">"Number of variables"</span>, ylabel<span class="op">=</span><span class="st">"Seconds"</span>)</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-25-output-1.png" width="599" height="431"></p>
</div>
</div>
<p>Wow, is that an almost 1000-fold speed advantage for matrix-based computation?</p>
<p>Again let’s show ratios of time taken to see:</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>speedup <span class="op">=</span> seconds_missing[:,<span class="dv">0</span>]<span class="op">/</span>seconds_missing[:,<span class="dv">1</span>]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Max speed-up rounded, for title</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>power <span class="op">=</span> np.floor(np.log10(speedup.<span class="bu">max</span>()))</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>lower <span class="op">=</span> np.floor(speedup.<span class="bu">max</span>() <span class="op">/</span> <span class="dv">10</span><span class="op">**</span>power) <span class="op">*</span> <span class="dv">10</span><span class="op">**</span>power</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> mticker</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="fl">2.7</span>), layout<span class="op">=</span><span class="st">"constrained"</span>)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>ax.plot(number_variables_large, </span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        speedup, </span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">'blue'</span>, </span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>        linewidth<span class="op">=</span><span class="dv">3</span>, </span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>        linestyle<span class="op">=</span><span class="st">'-'</span>,</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>        marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">"log"</span>)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Number of variables"</span>)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Speed advantage"</span>)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Vectorization up to "</span>)</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="ss">f"Vectorized code more than </span><span class="sc">{</span>lower<span class="sc">:.0f}</span><span class="ss">"</span> <span class="op">+</span> <span class="vs">r"$\bf</span><span class="sc">{X}</span><span class="vs">$ faster than loops"</span>)</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>ylim <span class="op">=</span> ax.get_ylim()</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylim((<span class="dv">1</span>,ylim[<span class="dv">1</span>]))</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>ticks_loc <span class="op">=</span> ax.get_yticks().tolist()</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_major_locator(mticker.FixedLocator(ticks_loc))</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>ytickLabels <span class="op">=</span> [<span class="bu">str</span>(<span class="bu">int</span>(n)) <span class="op">+</span> <span class="vs">r"$\bf</span><span class="sc">{X}</span><span class="vs">$"</span> <span class="cf">for</span> n <span class="kw">in</span> ticks_loc]</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>ax.set_yticklabels(ytickLabels)</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>fig.savefig(<span class="st">"tests-missing.svg"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-26-output-1.png" width="683" height="270"></p>
</div>
</div>
<p>Yes, indeed. An almost 1000-fold speed advantage!</p>
<p>Obviously you’d want to run a speed test multiple times but I do not think minor changes in computer state or exact data would change all that much. Nonetheless, you may want to know about my set up. I ran this on an AMD Ryzen 7 5800H with 32GB ram.</p>
<p>Oh yeah, I also mentioned something about <a href="https://en.wikipedia.org/wiki/Cohen's_kappa"><strong>Cohen’s kappa coefficient</strong></a>. This is something you may want to consider using if you want to take into the degree to which agreements can happen by chance. Cohen’s kappa is currently implemented in <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.cohen_kappa_score.html#sklearn.metrics.cohen_kappa_score">scikit-learn</a> but only handles single pairs. If you wanted to measure kappa among a large number of variables using scikit-learn then you’d have to put their function into a nested loop.</p>
<p>So I wrote a matrix-based version of cohen’s kappa that can handle missing values efficiently and I put it in this <a href="https://github.com/SourCherries/agreemat">GitHub repo</a>. It is basically like <code>pa_vect_missing()</code> but with some additional lines of code. So if you understood the discussion so far, then understanding my function for Cohen’s kappa should be straightforward.</p>
<p>I do not think that my solution for Cohen’s kappa would be useful for <a href="https://scikit-learn.org/stable/index.html">scikit-learn</a>, as Cohen’s kappa is primarily used there for model comparison with ground-truth labels. Unless you wanted to obtain a detailed picture of categorization errors among hundreds of thousands of models … I used my code for simple data exploration.</p>
</section>
<section id="sec-details" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sec-details"><span class="header-section-number">6</span> Nasty details for those interested</h2>
<p>If you want to implement your own solution, you may want to know about Numpy optimization. Especially if you’re not getting the gains you hoped for.</p>
<p>I highly recommend the <a href="http://shihchinw.github.io/2019/03/performance-tips-of-numpy-ndarray.html">blog post by Shih-Chin on this topic</a>. It is well written and informative!</p>
<p>Here I point out one little detail you might have missed in the my data-generation code:</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Xa <span class="op">=</span> np.random.choice([<span class="fl">0.</span>, <span class="fl">1.</span>], size<span class="op">=</span>(<span class="dv">1000</span>, <span class="dv">1000</span>), replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>Xb <span class="op">=</span> np.random.choice([<span class="dv">0</span>,  <span class="dv">1</span>],  size<span class="op">=</span>(<span class="dv">1000</span>, <span class="dv">1000</span>), replace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Xa has data type </span><span class="sc">{</span>Xa<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Xb has data type </span><span class="sc">{</span>Xb<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Xa has data type float64.
Xb has data type int64.</code></pre>
</div>
</div>
<p>You might remember that the presence of missing values will automatically cast data type to <code>float</code>. So all the data in <a href="#sec-curse">Section&nbsp;4</a> were <code>float64</code>.</p>
<p>When I wrote about computation without missing values (<a href="#sec-vectorization">Section&nbsp;3</a>), I was careful to keep this consistent and also use floating value: like <code>Xa</code> in the above code and not like <code>Xb</code>! Why be so careful?</p>
<p>As it turns out, this can have an effect on computational speed.</p>
<p>Let’s see how long it takes to do matrix multiplication on <code>float64</code> with 2 different orders of operation:</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> timeit</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>iterations <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>setup <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="st">import numpy as np</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="st">Xa = np.random.choice([0., 1.], size=(1000, 1000), replace=True)</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>tf <span class="op">=</span> timeit.Timer(<span class="st">"np.dot(Xa.transpose(), Xa)"</span>, setup<span class="op">=</span>setup)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>sec_order_1 <span class="op">=</span> tf.timeit(number<span class="op">=</span>iterations)<span class="op">/</span>iterations</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>tf <span class="op">=</span> timeit.Timer(<span class="st">"np.dot(Xa, Xa.transpose())"</span>, setup<span class="op">=</span>setup)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>sec_order_2 <span class="op">=</span> tf.timeit(number<span class="op">=</span>iterations)<span class="op">/</span>iterations</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"np.dot(Xa.transpose(), Xa) took </span><span class="sc">{</span>sec_order_1<span class="sc">}</span><span class="ss"> seconds."</span>)</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"np.dot(Xa, Xa.transpose()) took </span><span class="sc">{</span>sec_order_2<span class="sc">}</span><span class="ss"> seconds."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>np.dot(Xa.transpose(), Xa) took 0.009479861741001515 seconds.
np.dot(Xa, Xa.transpose()) took 0.008218657287998213 seconds.</code></pre>
</div>
</div>
<p>A reader that is familiar with matrix computation will notice that <code>np.dot(Xa, Xa.transpose())</code> does not make sense for our data. The <code>X</code> used in this blog post has samples along rows and variables along columns. So <code>np.dot(Xa, Xa.transpose())</code> would give comparisons of samples not variables. If we had constructed <code>X</code> so that rows and columns were opposite then <code>np.dot(Xa, Xa.transpose())</code> would give us the desired comparisons of variables.</p>
<p>I included both orders because based on <a href="http://shihchinw.github.io/2019/03/performance-tips-of-numpy-ndarray.html">Shih-Chin discussion of Numpy</a>, I suspected there might be a difference. There is a small difference so I decided to stick to <code>X</code> with variables along columns (and use <code>np.dot(Xa.transpose(), Xa)</code>). That format is in keeping with Pandas format and most data science.</p>
<p>Now what happens when our data <code>X</code> is <code>int64</code> instead of <code>float64</code>?</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>iterations <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>setup <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="st">import numpy as np</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="st">Xb = np.random.choice([0,  1],  size=(1000, 1000), replace=True)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>tf <span class="op">=</span> timeit.Timer(<span class="st">"np.dot(Xb.transpose(), Xb)"</span>, setup<span class="op">=</span>setup)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>sec_order_1 <span class="op">=</span> tf.timeit(number<span class="op">=</span>iterations)<span class="op">/</span>iterations</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>tf <span class="op">=</span> timeit.Timer(<span class="st">"np.dot(Xb, Xb.transpose())"</span>, setup<span class="op">=</span>setup)</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>sec_order_2 <span class="op">=</span> tf.timeit(number<span class="op">=</span>iterations)<span class="op">/</span>iterations</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"np.dot(Xb.transpose(), Xb) took </span><span class="sc">{</span>sec_order_1<span class="sc">}</span><span class="ss"> seconds."</span>)</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"np.dot(Xb, Xb.transpose()) took </span><span class="sc">{</span>sec_order_2<span class="sc">}</span><span class="ss"> seconds."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>np.dot(Xb.transpose(), Xb) took 1.0419683060199896 seconds.
np.dot(Xb, Xb.transpose()) took 0.47282201496003834 seconds.</code></pre>
</div>
</div>
<p>The most striking thing is that, regardless or operation order, computation of <code>int64</code> data is much slower!</p>
<p><strong>Even if your data are naturally integers it might make sense to cast them as float!</strong> That of course does not apply with missing data (contains <code>nan</code>), but your data might be originally integer in another scenario.</p>
<p>The second striking thing is that <code>np.dot(Xb, Xb.transpose())</code> is markedly faster than <code>np.dot(Xb.transpose(), Xb)</code>!</p>
<p><strong>If your data are integer and you do not have missing values then you will want to construct your data with variables along rows and perform matrix multiplication with the transposed data on the right-hand side!</strong></p>
<p>I should mention one more issue that is not computational but statistical. This discussion ignores how statistical inference works when we are performing pairwise deletion. If you are simply exploring your data or trying out different machine learning methods, then that’s not such an issue. But keep in mind that the effect of pairwise deletion on inference is likely to be tricky.</p>
</section>
<section id="sec-takeaway" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="sec-takeaway"><span class="header-section-number">7</span> Conclusion</h2>
<p>If you need to compute a measure/statistic for all pairwise comparisons among a large set of variables, then you can probably speed things up a lot with matrix multiplications. It may take some creativity, but hopefully this blog post can provide some inspiration.</p>
<p><strong>If you have missing data then matrix multiplication using Numpy masked arrays does pairwise deletion efficiently and that’s very useful to know!</strong></p>
<p>If you do decide to try out a similar solution for your measure/statistic, pay heed to <a href="#sec-details">Section&nbsp;6</a>. And watch out for the Numpy acceleration package <a href="https://jax.readthedocs.io/en/latest/index.html">Jax</a>. While it currently does not support <strong>masked arrays</strong>, perhaps it or some external package using Jax will do so in the future. That could potentially make the gains described here even greater.</p>
<p>The solution I present here for <strong>percentage agreement</strong> and <strong>Cohen’s kappa</strong> is not currently implemented in any major Python package.</p>
<p>Finally, watch out for my next post on how missing data are dealt with by current solutions that measure the <strong>covariance matrix</strong>, and why that matters.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="SourCherries/discussion" data-repo-id="R_kgDOKFfukQ" data-category="General" data-category-id="DIC_kwDOKFfukc4CYgWT" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>