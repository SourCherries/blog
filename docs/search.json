[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I research visual perception and neuroscience.\nI have also been dabbling in the social sciences.\nI have an ever-expanding bag of tricks that might be useful to others.\nTricks for coding, analysis and data visualization.\nSome of those tricks are now going here.\n\nBetter blogs than this one\nGwern\nAlex Guzey\nAndrew Gelman"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bag of Tricks",
    "section": "",
    "text": "Tricks for coding, data analysis and visualization\n\n\n\n\n\n\n\n\n  \n\n\n\n\nWhy masked arrays are useful for data science. Part 1\n\n\n\n\n\n\n\nanalysis\n\n\nmissing data\n\n\nnumpy\n\n\nvectorization\n\n\n\n\n\n\n\n\n\n\n\nAug 9, 2023\n\n\nCarl Gaspar\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/masked-arrays/index.html",
    "href": "posts/masked-arrays/index.html",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "",
    "text": "Ever needed to compare lots of variables and missing data made things super slow?\nA surprisingly wide range of measures that are core to data science can be accelerated with the use of matrix multiplication. You just need to get creative when reformulating your computation.\nBut real-world data has missing values and these can make matrix multiplication useless. Does that mean one must resort to inefficient for-loops to keep track of missing values?\nNo. Using Numpy masked arrays one can still reap the benefits of matrix multiplication whilst making full use of one’s data.\nHere I demonstrate the use of numpy masked arrays for the efficient calculation of percentage agreement among many binary variables.\nIn this post I cover:\nThe covariance matrix is another measure we can efficiently compute using MM and masked arrays. I am leaving that for another post where I also describe existing solutions (coming soon).\nThe solution I describe here for efficient computation of percentage agreement is not something in any major Python package.\nI also refer to a similar implementation of Cohen’s kappa I coded (in #sec-masked-arrays). Cohen’s kappa with efficient matrix-based handling of missing values is also missing in major Python packages.\nBut before we get to all that, let’s talk about matrix multiplication (MM)."
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-matmul",
    "href": "posts/masked-arrays/index.html#sec-matmul",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "1 Sums of products. Lots of them, fast",
    "text": "1 Sums of products. Lots of them, fast\nAs implemented in most popular packages like Python’s Numpy, MM let’s you rapidly calculate sums-of-products for many pairs of variables. So let’s start with sums-of-products.\nHere is a single variable and it’s sum-of-products:\n\nimport numpy as np\nx = np.array([1, 2, 3])\nsum_of_products = (x**2).sum()\nprint(sum_of_products)\n\n14\n\n\nNow we consider another variable y and calculate the sum-of-products between x and y:\n\ny = np.array([3, 2, 1])\nproducts = np.multiply(x, y)\nsum_of_products = products.sum()\nprint(products)\nprint(sum_of_products)\n\n[3 4 3]\n10\n\n\nNow we package our x and y as the column vectors of a single matrix:\n\nX = np.array([[1, 3],\n              [2, 2],\n              [3, 1]])\nnumber_observations, number_variables = X.shape\nprint(f\"{number_observations} observations (rows)\")\nprint(f\"{number_variables} variables (columns)\")\n\n3 observations (rows)\n2 variables (columns)\n\n\nWhy did with do this? If you matrix multiply X with itself you get something interesting:\n\nS = np.dot(X.transpose(), X)\nprint(S)\n\n[[14 10]\n [10 14]]\n\n\nS[0,0] is the sum-of-products of x with itself. S[0,1] is the sum-of-products of x with y. S[1,0] is also the sum-of-products of x with y. And S[1,1] is the sum-of-products of y with itself.\nIn other words, matrix multiplication (MM) gives you the sum-of-products for every pairwise comparison.\nAnd as mentioned earlier, MM is computed very quickly using packages like Numpy.\nBut why do we care about sums-of-products for every pairwise comparison?\nSo many interesting measures/statistics can be reformulated as an efficient sequence of MM.\nSo with just a little bit of cleverness you can turn your very inefficient for-loops into a very efficient sequence of matrix operations."
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-agreement",
    "href": "posts/masked-arrays/index.html#sec-agreement",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "2 Percentage agreement the slow way",
    "text": "2 Percentage agreement the slow way\nImagine that 8 people filled out a survey consisting of 4 yes/no items:\n\nimport pandas as pd\nX = np.array([[0, 0, 0, 0, 1, 1, 1, 1],\n              [0, 0, 0, 0, 1, 1, 1, 1],\n              [0, 1, 0, 1, 0, 1, 0, 1],\n              [1, 1, 1, 1, 0, 0, 0, 0]]).transpose()\n\ncol_labels = ['Item ' + str(i) for i in range(1,5)]\nrow_labels = ['Person ' + str(i) for i in range(1,9)]\nprint(pd.DataFrame(X, columns=col_labels, index=row_labels))\n\n          Item 1  Item 2  Item 3  Item 4\nPerson 1       0       0       0       1\nPerson 2       0       0       1       1\nPerson 3       0       0       0       1\nPerson 4       0       0       1       1\nPerson 5       1       1       0       0\nPerson 6       1       1       1       0\nPerson 7       1       1       0       0\nPerson 8       1       1       1       0\n\n\nYou want to know if there are associations among these items.\nA glance at this stylized data set suffices.\nItem 1 is perfectly positively associated with item 2 in this sample; 100 percent of the responses are in agreement.\nItem 1 is has no association with item 3 in this sample; guessing someone’s response to item 3 based their response to 1 is no better than a coin flip (50 percent).\nItem 1 is perfectly negatively associated with item 4; 0 percent of the responses are in agreement.\nIf you have a much larger data set, you might decide to use for-loops like this:\n\ndef pa_loop(X):\n    number_samples, number_variables = X.shape\n    percent_agreement = np.zeros((number_variables, number_variables))\n    for item_a in range(number_variables):\n        for item_b in range(item_a+1, number_variables):\n            percent_agreement[item_a, item_b] = (X[:, item_a]==X[:, item_b]).sum()\n    percent_agreement /= number_samples\n    return(percent_agreement)\n\nBut this can be slow for large data sets:\n\nfrom time import perf_counter\nnumber_samples, number_variables = 1000, 1000\nX = np.random.choice([0., 1.], size=(number_samples, number_variables), replace=True)\ntic = perf_counter()\npercent_agreement = pa_loop(X)\ntoc = perf_counter()\nprint(f\"Computing all pairwise percentage agreements took {toc-tic:0.4f} seconds.\")\n\nComputing all pairwise percentage agreements took 1.8570 seconds.\n\n\nThis may not seem so bad. But consider that\n\nThings will be much worse when missing data are considered (Section 4).\nData exploration might mean iterating this code many times.\nPercentage agreement is simpler than some other measures/statistics.\n\nHow can we use matrix multiplication to speed things up? We’ll have to use some tricks but it’s not that hard."
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-vectorization",
    "href": "posts/masked-arrays/index.html#sec-vectorization",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "3 Percentage agreement the fast way",
    "text": "3 Percentage agreement the fast way\nHere is a simple case with yes and no responses for 2 items coded as 1s and 0s respectively:\n\n\n\nitem 1\nitem 2\nagreement\nyes-yes\nno-no\n\n\n\n\n0\n0\n1\n0\n1\n\n\n0\n1\n0\n0\n0\n\n\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n1\n0\n\n\n\nWhat we want is a column like agreement above whose sum (2) gives us the number of agreements. We then divide 2 by 4 to get 50-percent agreement.\nTreating item 1 as a row vector and item 2 as a column vector, we can perform matrix multiplication to get the sum of yes-yes (1). As an intermediate step in matrix multiplication, our 2 vectors are multiplied value-by-value giving us the yes-yes column above. Summing is the final step of matrix multiplication (1).\nAgreements can be either yes-yes or no-no so we still need to obtain that sum before we can measure number of agreements. That’s easy. We simply flip the values in item 1 and item 2 from 0 to 1, and 1 to 0:\n\\[\nnew = \\lvert old-1 \\rvert\n\\]\nMatrix multiplication of these complementary vectors for item 1 and item 2 (not shown here) gives us our sum of no-no, whose intermediate step is the no-no column above.\nThe above example is for 2 items but the power of matrix multiplication is that we are multiplying matrices – as many items as we want. And the result is a matrix of all pairwise comparisons. In other words, we can obtain a matrix of percentage agreement for all pairwise comparisons using a simple sequence of matrix-based operations, like this:\n\ndef pa_vect(X):\n    number_samples, number_variables = X.shape # (n x k)\n    yesYes = np.dot(X.transpose(), X)          # counts of yes-yes (k x k)\n    np.abs(X-1, out=X)                         # [0,1] -> [1,0]\n    noNo = np.dot(X.transpose(), X)            # counts of no-no   (k x k)\n    S = yesYes + noNo                          # counts of agreements (k x k)\n    A = S / number_samples                     # percentage agreements (k x k)   \n    return(A)\n\nHow much faster is this compared to the loop-based computation?\n\nnumber_samples = 1000\nnumber_variables = [10, 50, 100, 500, 1000]\nseconds = np.zeros((len(number_variables), 2))\niterations = 36\n\nfor i, nvl in enumerate(number_variables):\n    for _ in range(iterations):\n        X = np.random.choice([0., 1.], size=(number_samples, nvl), replace=True)\n        tic = perf_counter(); percent_agreement = pa_loop(X); toc = perf_counter()\n        seconds_loop = toc-tic\n        tic = perf_counter(); percent_agreement = pa_vect(X); toc = perf_counter()\n        seconds_vect = toc-tic\n        seconds[i, 0] += seconds_loop\n        seconds[i, 1] += seconds_vect\n\nseconds /= iterations\n    \ndf = pd.DataFrame(seconds, \n                  columns=['loop','matrix-based'],\n                  index=number_variables)\ndf\n\n\n\n\n\n  \n    \n      \n      loop\n      matrix-based\n    \n  \n  \n    \n      10\n      0.000217\n      0.000156\n    \n    \n      50\n      0.005415\n      0.000235\n    \n    \n      100\n      0.021027\n      0.000606\n    \n    \n      500\n      0.500720\n      0.006657\n    \n    \n      1000\n      1.909704\n      0.022183\n    \n  \n\n\n\n\nLet’s examine the speed up graphically:\n\nimport matplotlib.pyplot as plt\n\ndf.plot(loglog=True, xlabel=\"Number of variables\", ylabel=\"Seconds\")\nplt.show()\n\n\n\n\nMatrix-based computation is definitely faster!\nHow much faster exactly?\nDividing the time taken by loop-based computation by the time taken by matrix-based computation gives us a speed-up. The larger the number the stronger the advantage for matrix-based computation:\n\nspeed_up = seconds[:,0] / seconds[:,1]\nplt.semilogx(number_variables, speed_up)\nplt.xlabel(\"Number of variables\")\nplt.ylabel(\"Speed advantage\")\nplt.title(\"Matrix-based operation beats loops by miles\")\nplt.show()"
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-curse",
    "href": "posts/masked-arrays/index.html#sec-curse",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "4 The curse of missing data",
    "text": "4 The curse of missing data\nNumpy is efficient because its data structures (matrices, vectors) have homogeneous elements. Everything in a numpy matrix for example is int32 or whatever data type you set it to be (e.g., float64).\nIf you have an element that is undefined for some reason, like a missing value for example, then it is usually represented as nan. That stands for not-a-number and is common in programming languages. Note that nan is only defined for floating point data types.\nFor convenience, let’s assign a variable to represent np.nan so we do not have to type np.nan all the time:\n\nM = np.nan\n\nNow let’s see why missing values in Numpy (nan) can be a problem for our MM solutions.\nIf we do any arithmetic that involves a nan we get a nan as a result:\n\nprint(f\"10 + nan is {10 + M}\")\nprint(f\"23 * nan is {23 * M}\")\n\n10 + nan is nan\n23 * nan is nan\n\n\nSo if we do matrix multiplication, we will get nan for every pair that has at least one nan:\n\nx = np.array([1, 2, 3, 4]).reshape((4,1))\ny = np.array([1, 2, 3, M]).reshape((4,1))\nmm = np.dot(x.transpose(), y)\nprint(f\"matrix multiplication of {x.flatten()} and {y.flatten()} is {mm}.\")\n\nmatrix multiplication of [1 2 3 4] and [ 1.  2.  3. nan] is [[nan]].\n\n\nNow let’s see how we can deal with missing values in data sets.\nThere are simple cases which are uncommon, and there are complex cases which are common.\nHere is an extremely simple case:\n\nX = np.array([[0, 0, 0, 1],\n              [0, 0, 1, 1],\n              [1, 1, 0, 0],\n              [1, 1, 1, 0],\n              [M, M, M, M]])\ncol_labels = ['Item ' + str(i) for i in range(1,5)]\nrow_labels = ['Person ' + str(i) for i in range(1,6)]\nprint(pd.DataFrame(X, columns=col_labels, index=row_labels))\n\n          Item 1  Item 2  Item 3  Item 4\nPerson 1     0.0     0.0     0.0     1.0\nPerson 2     0.0     0.0     1.0     1.0\nPerson 3     1.0     1.0     0.0     0.0\nPerson 4     1.0     1.0     1.0     0.0\nPerson 5     NaN     NaN     NaN     NaN\n\n\nHere we can perform listwise deletion, with no loss of information:\n\nX[:-1,:]\n\narray([[0., 0., 0., 1.],\n       [0., 0., 1., 1.],\n       [1., 1., 0., 0.],\n       [1., 1., 1., 0.]])\n\n\nBut the missing values in real data will often be in different records for different variables. Here is an extreme case:\n\nX = np.array([[0, 0, M, M],\n              [0, 0, M, M],\n              [1, 1, M, M],\n              [1, 1, M, M],\n              [0, M, 0, M],\n              [0, M, 1, M],\n              [1, M, 0, M],\n              [1, M, 1, M],\n              [0, M, M, 1],\n              [0, M, M, 1],\n              [1, M, M, 0],\n              [1, M, M, 0]])\n\nIf we do listwise deletion we end up with no data.\nWhat we want is pairwise deletion instead of listwise deletion. We want to only exclude samples on a pairwise basis in order to retain the most information.\nThis is pretty straightforward with our loop-based code. We simply add list comprehensions inside the inner loop, which excludes samples whenever a value is missing for one of the pairs under consideration:\n\nimport math\n\ndef pa_loop_missing(X):\n    _, number_variables = X.shape\n    percent_agreement = np.zeros((number_variables, number_variables))\n    for item_a in range(number_variables):\n        for item_b in range(item_a+1, number_variables):\n                x = X[:, item_a]\n                y = X[:, item_b]\n                # remove observations where missing for either x or y\n                products = [a*b for a, b in zip(x,y)]\n                nx = [xi for xi, pi in zip(x, products) if not math.isnan(pi)]\n                ny = [yi for yi, pi in zip(y, products) if not math.isnan(pi)]\n                sumA = sum([va==vb for va, vb in zip(nx, ny)])\n                totA = len(nx)\n                percent_agreement[item_a, item_b] = [sumA / totA if totA > 0 else math.nan][0]\n    return(percent_agreement)\n  \npa_loop_missing(X)\n\narray([[0. , 1. , 0.5, 0. ],\n       [0. , 0. , nan, nan],\n       [0. , 0. , 0. , nan],\n       [0. , 0. , 0. , 0. ]])\n\n\nThis works but as we will see in Section 5, this solution is very slow. That is not a surprise since we now effectively have 3 nested loops.\nAnd if we try out matrix-based solution we end up no result except for the agreement of the first item with itself:\n\npa_vect(X)\n\narray([[ 1., nan, nan, nan],\n       [nan, nan, nan, nan],\n       [nan, nan, nan, nan],\n       [nan, nan, nan, nan]])\n\n\nOf course. We already knew this.\nIn fact, it seems impossible to avoid for-loops if one wants to perform pairwise deletion.\nOr is it?"
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-masked-arrays",
    "href": "posts/masked-arrays/index.html#sec-masked-arrays",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "5 Masked arrays to the rescue",
    "text": "5 Masked arrays to the rescue\nAs it turns out, numpy masked arrays effectively performs pairwise deletion when a matrix multiplication is performed!\nDespite being very valuable, this feature of masked arrays is not something that appears to be commonly appreciated in discussions of what makes masked arrays useful.\nFor example, see the top-rated responses to this Stack Overflow query on Why are Numpy masked arrays useful? Practical examples like what’s presented here are hard to find.\nSo let’s make sure pairwise deletion is indeed performed using a matrix multiplication of masked arrays. I was not sure myself and had to check using numerous examples. Here is a really simple example I showed you before:\n\nX = np.array([[0, 0, M, M],\n              [0, 0, M, M],\n              [1, 1, M, M],\n              [1, 1, M, M],\n              [0, M, 0, M],\n              [0, M, 1, M],\n              [1, M, 0, M],\n              [1, M, 1, M],\n              [0, M, M, 1],\n              [0, M, M, 1],\n              [1, M, M, 0],\n              [1, M, M, 0]])\n\ncol_labels = ['Item ' + str(i) for i in range(1,X.shape[1]+1)]\nrow_labels = ['Person ' + str(i) for i in range(1,X.shape[0]+1)]\n\nprint(pd.DataFrame(X, columns=col_labels, index=row_labels))\n\n           Item 1  Item 2  Item 3  Item 4\nPerson 1      0.0     0.0     NaN     NaN\nPerson 2      0.0     0.0     NaN     NaN\nPerson 3      1.0     1.0     NaN     NaN\nPerson 4      1.0     1.0     NaN     NaN\nPerson 5      0.0     NaN     0.0     NaN\nPerson 6      0.0     NaN     1.0     NaN\nPerson 7      1.0     NaN     0.0     NaN\nPerson 8      1.0     NaN     1.0     NaN\nPerson 9      0.0     NaN     NaN     1.0\nPerson 10     0.0     NaN     NaN     1.0\nPerson 11     1.0     NaN     NaN     0.0\nPerson 12     1.0     NaN     NaN     0.0\n\n\nClearly the sum of products between item 1 and itself should be 6, between item 1 and 2 should be 2, between item 1 and 3 should be 1, and between item 1 and 4 should be 0. You easily calculate the rest yourself.\nLet’s see if matrix multiplication with masked arrays is consistent with pairwise deletion.\nThe first step is to import the masked array module, and convert X to a masked array such that nan values are identified as masked:\n\nimport numpy.ma as ma\n\nR = ma.masked_invalid(X)\n\nNow the rest is the easy. The masked array module contains almost all of the same functionality as numpy itself. So for example we can write ma.dot() instead of np.dot():\n\nyesYes = ma.dot(R.transpose(), R)\n\nprint(pd.DataFrame(yesYes, columns=col_labels, index=col_labels))\n\n        Item 1  Item 2  Item 3  Item 4\nItem 1     6.0     2.0     1.0     0.0\nItem 2     2.0     2.0     NaN     NaN\nItem 3     1.0     NaN     2.0     NaN\nItem 4     0.0     NaN     NaN     2.0\n\n\nFantastic! Pairwise deletion without for loops!\nBut is this fast? Can we still get those juicy speed gains using matrix multiplication on masked arrays?\nLet’s find out. First let’s re-code our function for matrix-computation of percentage agreement to perform all operations on a masked-array version of the data:\n\ndef pa_vect_missing(X):\n    R = ma.masked_invalid(X)                # (n x k)\n    yesYes = ma.dot(R.transpose(), R)       # counts of yes-yes (k x k)\n    F = ma.abs(R-1)                         # [0,1] -> [1,0]\n    noNo = ma.dot(F.transpose(), F)         # counts of no-no   (k x k)\n    S = yesYes + noNo                       # counts of agreements (k x k)\n    valid = np.ones_like(R)                 # valid responses (n x k)\n    valid[ma.getmaskarray(R)] = 0\n    N = np.dot(valid.transpose(), valid)    # valid count (k x k)\n    A = ma.multiply(S, N**-1)               # percentage agreement (k x k)\n    return(A)\n\nAnd now let’s compare our new loop- and matrix-based functions across a range of data sizes. Here I simulate binary responses with 20-percent missing data on average, randomly dispersed across sample and variable:\n\nrng = np.random.default_rng(seed=12345)\n\nresponses, probs = [0., 1., M], [.4, .4, .2]\nnumber_samples_large = 1000\nnumber_variables_large = [10, 50, 100, 500, 1000]\nseconds_missing = np.zeros((len(number_variables_large), 2))\niterations = 2\n\nfor i, nvl in enumerate(number_variables_large):\n  for _ in range(iterations):\n    X = rng.choice(responses, \n                   size=(number_samples_large, nvl), \n                   replace=True,\n                   p=probs)\n    tic = perf_counter()\n    percent_agreement = pa_loop_missing(X)\n    toc = perf_counter()\n    seconds_loop = toc-tic\n    tic = perf_counter()\n    percent_agreement = pa_vect_missing(X)\n    toc = perf_counter()\n    seconds_vect = toc-tic\n    seconds_missing[i, 0] += seconds_loop\n    seconds_missing[i, 1] += seconds_vect\n\nseconds_missing /= iterations\n\ndf_missing = pd.DataFrame(seconds_missing, \n                          columns=['loop','vectorized'],\n                          index=number_variables_large)\n\ndf_missing.plot(loglog=True, xlabel=\"Number of variables\", ylabel=\"Seconds\")\nplt.show()\n\ndf_missing.to_csv(\"tests_missing.csv\")\n\n\n\n\nWow, is that an almost 1000-fold speed advantage for matrix-based computation?\nAgain let’s show ratios of time taken to see:\n\nspeedup = seconds_missing[:,0]/seconds_missing[:,1]\n\n# Max speed-up rounded, for title\npower = np.floor(np.log10(speedup.max()))\nlower = np.floor(speedup.max() / 10**power) * 10**power\n\nimport matplotlib.ticker as mticker\n\nfig, ax = plt.subplots(figsize=(7, 2.7), layout=\"constrained\")\nax.plot(number_variables_large, \n        speedup, \n        color='blue', \n        linewidth=3, \n        linestyle='-',\n        marker='o')\nax.set_xscale(\"log\")\nax.set_xlabel(\"Number of variables\")\nax.set_ylabel(\"Speed advantage\")\nax.set_title(\"Vectorization up to \")\nax.set_title(f\"Vectorized code more than {lower:.0f}\" + r\"$\\bf{X}$ faster than loops\")\nylim = ax.get_ylim()\nax.set_ylim((1,ylim[1]))\nticks_loc = ax.get_yticks().tolist()\nax.yaxis.set_major_locator(mticker.FixedLocator(ticks_loc))\nytickLabels = [str(int(n)) + r\"$\\bf{X}$\" for n in ticks_loc]\nax.set_yticklabels(ytickLabels)\nplt.show()\n\nfig.savefig(\"tests-missing.svg\")\n\n\n\n\nYes, indeed. An almost 1000-fold speed advantage!\nObviously you’d want to run a speed test multiple times but I do not think minor changes in computer state or exact data would change all that much. Nonetheless, you may want to know about my set up. I ran this on an AMD Ryzen 7 5800H with 32GB ram.\nOh yeah, I also mentioned something about Cohen’s kappa coefficient. This is something you may want to consider using if you want to take into the degree to which agreements can happen by chance. Cohen’s kappa is currently implemented in scikit-learn but only handles single pairs. If you wanted to measure kappa among a large number of variables using scikit-learn then you’d have to put their function into a nested loop.\nSo I wrote a matrix-based version of cohen’s kappa that can handle missing values efficiently and I put it in this GitHub repo. It is basically like pa_vect_missing() but with some additional lines of code. So if you understood the discussion so far, then understanding my function for Cohen’s kappa should be straightforward.\nI do not think that my solution for Cohen’s kappa would be useful for scikit-learn, as Cohen’s kappa is primarily used there for model comparison with ground-truth labels. Unless you wanted to obtain a detailed picture of categorization errors among hundreds of thousands of models … I used my code for simple data exploration."
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-details",
    "href": "posts/masked-arrays/index.html#sec-details",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "6 Nasty details for those interested",
    "text": "6 Nasty details for those interested\nIf you want to implement your own solution, you may want to know about Numpy optimization. Especially if you’re not getting the gains you hoped for.\nI highly recommend the blog post by Shih-Chin on this topic. It is well written and informative!\nHere I point out one little detail you might have missed in the my data-generation code:\n\nXa = np.random.choice([0., 1.], size=(1000, 1000), replace=True)\nXb = np.random.choice([0,  1],  size=(1000, 1000), replace=True)\nprint(f\"Xa has data type {Xa.dtype}.\")\nprint(f\"Xb has data type {Xb.dtype}.\")\n\nXa has data type float64.\nXb has data type int64.\n\n\nYou might remember that the presence of missing values will automatically cast data type to float. So all the data in Section 4 were float64.\nWhen I wrote about computation without missing values (Section 3), I was careful to keep this consistent and also use floating value: like Xa in the above code and not like Xb! Why be so careful?\nAs it turns out, this can have an effect on computational speed.\nLet’s see how long it takes to do matrix multiplication on float64 with 2 different orders of operation:\n\nimport timeit\niterations = 1000\n\nsetup = \"\"\"\nimport numpy as np\nXa = np.random.choice([0., 1.], size=(1000, 1000), replace=True)\n\"\"\"\ntf = timeit.Timer(\"np.dot(Xa.transpose(), Xa)\", setup=setup)\nsec_order_1 = tf.timeit(number=iterations)/iterations\ntf = timeit.Timer(\"np.dot(Xa, Xa.transpose())\", setup=setup)\nsec_order_2 = tf.timeit(number=iterations)/iterations\nprint(f\"np.dot(Xa.transpose(), Xa) took {sec_order_1} seconds.\")\nprint(f\"np.dot(Xa, Xa.transpose()) took {sec_order_2} seconds.\")\n\nnp.dot(Xa.transpose(), Xa) took 0.00926350842500142 seconds.\nnp.dot(Xa, Xa.transpose()) took 0.008056458486000338 seconds.\n\n\nA reader that is familiar with matrix computation will notice that np.dot(Xa, Xa.transpose()) does not make sense for our data. The X used in this blog post has samples along rows and variables along columns. So np.dot(Xa, Xa.transpose()) would give comparisons of samples not variables. If we had constructed X so that rows and columns were opposite then np.dot(Xa, Xa.transpose()) would give us the desired comparisons of variables.\nI included both orders because based on Shih-Chin discussion of Numpy, I suspected there might be a difference. There is a small difference so I decided to stick to X with variables along columns (and use np.dot(Xa.transpose(), Xa)). That format is in keeping with Pandas format and most data science.\nNow what happens when our data X is int64 instead of float64?\n\niterations = 50\nsetup = \"\"\"\nimport numpy as np\nXb = np.random.choice([0,  1],  size=(1000, 1000), replace=True)\n\"\"\"\ntf = timeit.Timer(\"np.dot(Xb.transpose(), Xb)\", setup=setup)\nsec_order_1 = tf.timeit(number=iterations)/iterations\ntf = timeit.Timer(\"np.dot(Xb, Xb.transpose())\", setup=setup)\nsec_order_2 = tf.timeit(number=iterations)/iterations\nprint(f\"np.dot(Xb.transpose(), Xb) took {sec_order_1} seconds.\")\nprint(f\"np.dot(Xb, Xb.transpose()) took {sec_order_2} seconds.\")\n\nnp.dot(Xb.transpose(), Xb) took 1.0244241412799966 seconds.\nnp.dot(Xb, Xb.transpose()) took 0.4779843139599689 seconds.\n\n\nThe most striking thing is that, regardless or operation order, computation of int64 data is much slower!\nEven if your data are naturally integers it might make sense to cast them as float! That of course does not apply with missing data (contains nan), but your data might be originally integer in another scenario.\nThe second striking thing is that np.dot(Xb, Xb.transpose()) is markedly faster than np.dot(Xb.transpose(), Xb)!\nIf your data are integer and you do not have missing values then you will want to construct your data with variables along rows and perform matrix multiplication with the transposed data on the right-hand side!\nI should mention one more issue that is not computational but statistical. This discussion ignores how statistical inference works when we are performing pairwise deletion. If you are simply exploring your data or trying out different machine learning methods, then that’s not such an issue. But keep in mind that the effect of pairwise deletion on inference is likely to be tricky."
  },
  {
    "objectID": "posts/masked-arrays/index.html#sec-takeaway",
    "href": "posts/masked-arrays/index.html#sec-takeaway",
    "title": "Why masked arrays are useful for data science. Part 1",
    "section": "7 Conclusion",
    "text": "7 Conclusion\nIf you need to compute a measure/statistic for all pairwise comparisons among a large set of variables, then you can probably speed things up a lot with matrix multiplications. It may take some creativity, but hopefully this blog post can provide some inspiration.\nIf you have missing data then matrix multiplication using Numpy masked arrays does pairwise deletion efficiently and that’s very useful to know!\nIf you do decide to try out a similar solution for your measure/statistic, pay heed to Section 6. And watch out for the Numpy acceleration package Jax. While it currently does not support masked arrays, perhaps it or some external package using Jax will do so in the future. That could potentially make the gains described here even greater.\nThe solution I present here for percentage agreement and Cohen’s kappa is not currently implemented in any major Python package.\nFinally, watch out for my next post on how missing data are dealt with by current solutions that measure the covariance matrix, and why that matters."
  },
  {
    "objectID": "todo.html",
    "href": "todo.html",
    "title": "Carl Gaspar",
    "section": "",
    "text": "Stackoverflow reply with link to post 🚀\nThank you reply to Chinese guy with link to post 🚀\nSend to Alex Guzey 🚀\nFind image to share\n\nmasked-array post -> plot of speed up\nblog itself -> _________\n\nBlog Social Preview\n\n\nImages should be at least 640×320px (1280×640px for best display). 40pt border.\n\n\nImage for post\n\n\nThere’s a Social Preview?\n\n\nShare\n\n\nTwitter\nLinkedIn\n\n\nPut blog home page link on\n\n\nTwitter\nLinkedIn\nCV\n\n# ZU\n\nAdvisee\nSupervisee\nNeuro psychologist\nGaming manuscript\nCAS files\nSyllabi\n\n# Preview for social media\nhttps://quarto.org/docs/websites/website-tools.html#twitter-cards\nhttps://quarto.org/docs/websites/website-tools.html#preview-images"
  },
  {
    "objectID": "todo.html#image",
    "href": "todo.html#image",
    "title": "Carl Gaspar",
    "section": "Image",
    "text": "Image\nChange tests-missing.svg to featured.png\n\nmake_featured.py temporary script to test\n\nwrite to png\nfont sizes et cetera\n\nprint(plt.style.available)\nplt.style.use('ggplot')\ngallery\n\nlarge font\nseaborn-poster\nfivethirtyeight\n\n\n\ncopy code into qmd and re-render post\n\ncopy only fig format and export\nname as “featured.png”\nOR just export tests-missing.csv in qmd for separate script"
  },
  {
    "objectID": "todo.html#post",
    "href": "todo.html#post",
    "title": "Carl Gaspar",
    "section": "Post",
    "text": "Post\nAdd to index.qmd yml for masked-array post:\nimage: featured.png image-alt: “Hand-drawn black and white wireframe sketch of a tweet containing a preview frame showing the text ‘TWITTER CARD?!?’” card-style: “summary”"
  }
]